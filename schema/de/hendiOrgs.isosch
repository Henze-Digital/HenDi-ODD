<?xml version="1.0" encoding="utf-8"?>
<schema xmlns="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2">
   <title>ISO Schematron rules</title>
   <!-- This file generated 2023-06-21T13:21:42Z by 'extract-isosch.xsl'. -->
   <!-- ********************* -->
   <!-- namespaces, declared: -->
   <!-- ********************* -->
   <ns uri="https://henze-digital.de/ns/xslt-functions" prefix="hendi-xsl"/>
   <ns uri="https://henze-digital.de/ns/xslt-functions" prefix="hendi-xsl"/>
   <ns uri="http://www.functx.com" prefix="functx"/>
   <ns prefix="mei" uri="http://www.music-encoding.org/ns/mei"/>
   <!-- ********************* -->
   <!-- namespaces, implicit: -->
   <!-- ********************* -->
   <ns prefix="hendi" uri="http://henze-digital.zenmem.de/ns/1.0"/>
   <ns prefix="tei" uri="http://www.tei-c.org/ns/1.0"/>
   <!-- ************ -->
   <!-- constraints: -->
   <!-- ************ -->
   <pattern id="schematron-constraint-hendiOrgs-att.written-hand-hand-reference-1">
      <rule context="tei:*[@hand]">
         <assert test="id(substring(@hand,2))">There must be an element with the xml:id = "<value-of select="substring(@hand,2)"/>" which is the target of this @hand.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.breaking-break-hyphenation-whitespace-2">
      <rule context="tei:*[@break]">
         <report test="matches((following-sibling::text() | following-sibling::element())[1], '^\s') or matches((preceding-sibling::text() | preceding-sibling::element())[last()], '\s$')">There must not be any whitespace before or after the <name/> element when the @break attribute is applied.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable.w3c-att-datable-w3c-when-3">
      <rule context="tei:*[@when]">
         <report test="@notBefore|@notAfter|@from|@to" role="nonfatal">The @when attribute cannot be used with any other att.datable.w3c attributes.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable.w3c-att-datable-w3c-from-4">
      <rule context="tei:*[@from]">
         <report test="@notBefore" role="nonfatal">The @from and @notBefore attributes cannot be used together.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable.w3c-att-datable-w3c-to-5">
      <rule context="tei:*[@to]">
         <report test="@notAfter" role="nonfatal">The @to and @notAfter attributes cannot be used together.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable-calendar-6">
      <rule context="tei:*[@calendar]">
         <assert test="string-length(.) gt 0"> @calendar indicates one or more systems or calendars to
              which the date represented by the content of this element belongs, but this
              <name/> element has no textual content.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable-calendar-7">
      <rule context="tei:*[@calendar]">
         <assert test="string-length(.) gt 0"> @calendar indicates one or more systems or calendars to
              which the date represented by the content of this element belongs, but this
              <name/> element has no textual content.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.datable-calendar-calendar-8">
      <rule context="tei:*[@calendar]">
         <assert test="string-length(.) gt 0"> @calendar indicates one or more systems or calendars to
              which the date represented by the content of this element belongs, but this
              <name/> element has no textual content.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.global.source-source-only_1_ODD_source-9">
      <rule context="tei:*[@source]">
         <let name="srcs" value="tokenize( normalize-space(@source),' ')"/>
         <report test="( self::tei:classRef                                     | self::tei:dataRef                                     | self::tei:elementRef                                     | self::tei:macroRef                                     | self::tei:moduleRef                                     | self::tei:schemaSpec )                                     and                                     $srcs[2]">
                                    When used on a schema description element (like
                                    <value-of select="name(.)"/>), the @source attribute
                                    should have only 1 value. (This one has <value-of select="count($srcs)"/>.)
                                </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.typed-subtypeTyped-10">
      <rule context="tei:*[@subtype]">
         <assert test="@type">The <name/> element should not be categorized in detail with @subtype unless also categorized in general with @type</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.pointing-targetLang-11">
      <rule context="tei:*[not(self::tei:schemaSpec)][@targetLang]">
         <assert test="@target">@targetLang should only be used on <name/> if @target is specified.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-extent-within-physDesc-12">
      <rule context="tei:p">
         <report test="@n='extent' and not(parent::tei:physDesc)">
                        The value 'extent' must only be used within the tei:physDesc.
                    </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-extent-only-once-13">
      <rule context="tei:physDesc">
         <report test="count(tei:p[@n='extent']) gt 1">There must only be one tei:p with @n='extent'</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-extent-regex-14">
      <rule context="tei:p[@n='extent']">
         <assert test="matches(., '^\d+ D?Bl\. \(\d+ b\. S\.( (o|einschl)\. Adr\.)?( u\. Umschlag)?\)$')">The 'extent' must match the pattern '^\d+ D?Bl\. \(\d+ b\. S\.( (o|einschl)\. Adr\.)?( u\. Umschlag)?\)$'</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-abstractModel-structure-p-in-ab-or-p-15">
      <rule context="tei:p">
         <report test="(ancestor::tei:p or ancestor::tei:ab)                          and not(parent::tei:exemplum                         |parent::tei:item                         |parent::tei:note                         |parent::tei:q                         |parent::tei:quote                         |parent::tei:remarks                         |parent::tei:said                         |parent::tei:sp                         |parent::tei:stage                         |parent::tei:cell                         |parent::tei:figure                         |parent::tei:footNote)">
                        Abstract model violation: Paragraphs may not contain other paragraphs or ab elements.
                    </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-abstractModel-structure-l-16">
      <rule context="tei:p">
         <report test="(ancestor::tei:l or ancestor::tei:lg)                          and not(parent::tei:figure or parent::tei:note or ancestor::tei:floatingText or parent::tei:footNote)">
                        Abstract model violation: Lines may not contain higher-level structural elements such as div, p, or ab, unless p is a child of figure or note, or is a descendant of floatingText.
                    </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-p-abstractModel-structure-p-in-l-or-lg-17">
      <rule context="tei:p">
         <report test="    (ancestor::tei:l or ancestor::tei:lg)                          and not( ancestor::tei:floatingText                                 |parent::tei:figure                                 |parent::tei:note                                )">
        Abstract model violation: Lines may not contain higher-level structural elements such as div, p, or ab, unless p is a child of figure or note, or is a descendant of floatingText.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-desc-deprecationInfo-only-in-deprecated-18">
      <rule context="tei:desc[ @type eq 'deprecationInfo']">
         <assert test="../@validUntil">Information about a
        deprecation should only be present in a specification element
        that is being deprecated: that is, only an element that has a
        @validUntil attribute should have a child &lt;desc
        type="deprecationInfo"&gt;.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-sic-empty-sic-19">
      <rule context="tei:sic">
         <report test="normalize-space(.) = ''">ein sic sollte immer Text enthalten. Alternativ kann ein supplied oder gap eingesetzt werden.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-name-name-typeDep-20">
      <rule context="tei:name[@type='dep']">
         <assert test="parent::tei:orgName and ancestor::tei:org">The value 'dep' is only allowed within the doctype 'orgs'.</assert>
      </rule>
   </pattern>
   <pattern is-a="node-typeNkey">
      <param name="node" value="tei:name"/>
   </pattern>
   <pattern is-a="node-typeNkey">
      <param name="node" value="tei:rs"/>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-addrLine-addrLineStreet-23">
      <rule context="tei:addrLine">
         <report test="tei:street and count(./node()) gt 1">When the element street is used no text nodes are allowed within addrLine.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-date-types-for-corresp-action-24">
      <rule context="tei:date[parent::tei:correspAction][@type]">
         <assert test="@type = ('editor','postal','source')">Valid values for dates in the correspAction are 'editor','postal','source'.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-dateHeuristics2-25">
      <rule context="tei:date[@notBefore castable as xs:date and @notAfter castable as xs:date]">
         <report test="xs:date(@notBefore) gt xs:date(@notAfter)">the date value of notBefore is later than notAfter</report>
      </rule>
      <rule context="tei:date[@notBefore castable as xs:gYear and @notAfter castable as xs:gYear]">
         <report test="xs:date(concat(@notBefore, '-01-01')) gt xs:date(concat(@notAfter, '-01-01'))">the date value of notBefore is later than notAfter</report>
      </rule>
      <rule context="tei:date[@notBefore castable as xs:gYear and @notAfter castable as xs:date]">
         <report test="xs:date(concat(@notBefore, '-01-01')) gt xs:date(@notAfter)">the date value of notBefore is later than notAfter</report>
      </rule>
      <rule context="tei:date[@notBefore castable as xs:date and @notAfter castable as xs:gYear]">
         <report test="xs:date(@notBefore) gt xs:date(concat(@notAfter, '-12-31'))">the date value of notBefore is later than notAfter</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-dateHeuristics3-26">
      <rule context="tei:date">
         <report test="(@from or @to) and (@when or @notAfter or @notBefore)">cooccurence of date and duration attributes</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-dateHeuristics4-27">
      <rule context="tei:date">
         <report test="@when and (@notAfter or @notBefore)">cooccurence of exact and uncertain date attributes</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-dateHeuristics5-28">
      <rule context="tei:date">
         <assert test="@when or @notBefore or @notAfter or @from or @to or @cert='unknown' or matches(., '0000|o\.J\.|unknown') or ancestor::tei:text">tei:date ben√∂tigt ein Attribut @when, @notBefore o.√§.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-dateHeuristics6-29">
      <rule context="tei:date[some $i in (@when, @notBefore, @notAfter, @from, @to) satisfies $i castable as xs:date]">
         <report test="every $j in (@when, @notBefore, @notAfter, @from, @to)[. castable as xs:date] satisfies xs:date($j) gt current-date()">some attribute value of <name/> is greater than the current date</report>
      </rule>
      <rule context="tei:date[some $i in (@when, @notBefore, @notAfter, @from, @to) satisfies $i castable as xs:gYear]">
         <report test="every $j in (@when, @notBefore, @notAfter, @from, @to)[. castable as xs:gYear] satisfies number($j) gt year-from-date(current-date())">some attribute value of <name/> is greater than the current date</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-date-julian-before-1582-30">
      <rule context="tei:date[@calendar='Julian']">
         <report test="some $i in (@when, @notBefore, @notAfter, @from, @to) satisfies $i lt '1582-10-15'">Before October 15, 1582 the default calendar is Julian so no extra calendar declaration is needed.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-ptr-ptr-target-31">
      <rule context="tei:ptr[not(starts-with(@target, 'http'))]">
         <assert test="following::tei:note[@xml:id=substring(current()/@target,2)]">
                       The note element indicated by @target (<value-of select="@target"/>) must follow the current element <name/>. 
                        Otherwise the target must be some external URL prefixed with 'http'.
                    </assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-ptr-duplicate-ptr-32">
      <rule context="tei:ptr">
         <report test="following::tei:ptr[@target=current()/@target]">
                   There must be only one pointer with the @target (<value-of select="@target"/>)
                </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-ptr-ptrAtts-33">
      <rule context="tei:ptr">
         <report test="@target and @cRef">Only one of the
attributes @target and @cRef may be supplied on <name/>.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-ref-prev-next-correspContext-34">
      <rule context="tei:ref">
         <report test="@type=('previousLetterFromAddressee', 'nextLetterFromAddressee') and not(parent::tei:correspContext)">'previousLetterFromAddressee' and 'nextLetterFromAddressee' are only used within the correspContext element.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-ref-refAtts-35">
      <rule context="tei:ref">
         <report test="@target and @cRef">Only one of the
	attributes @target' and @cRef' may be supplied on <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-list-gloss-list-36">
      <rule context="tei:list">
         <report test="./tei:label and not(@type='gloss')">Labels are only allowed in lists of type='gloss'</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-list-gloss-list-must-have-labels-37">
      <rule context="tei:list[@type='gloss']">
         <assert test="tei:label">The content of a "gloss" list should include a sequence of one or more pairs of a label element followed by an item element</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-translation-notes-corresp-38">
      <rule context="tei:note[parent::tei:notesStmt]">
         <report test="@type='translation' and not(@corresp)" role="fatal">A note that contains a translation must be liked to the original using @corresp.</report>
         <report test="@type='translation' and not(@xml:lang)">The language must be defined with @xml:lang.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-restriction-notes-corresp-39">
      <rule context="tei:note[parent::tei:notesStmt]">
         <report test="@type='restriction' and not(@corresp)" role="fatal">A note that contains a restriction must be liked to the original using @corresp.</report>
         <report test="@type='restriction' and not(@xml:lang)">The language must be defined with @xml:lang.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-note-in-text-40">
      <rule context="tei:note[not(parent::tei:org or parent::tei:place or parent::tei:person or parent::tei:notesStmt or parent::tei:biblStruct or parent::tei:imprint or @type=('addInfo','comment'))]">
         <assert test="@resp">It is required to give a responsibillity (@resp) on note.</assert>
         <assert test="@type">It is required to classify the note with @type.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-notesStmt-notes-41">
      <rule context="tei:note[parent::tei:notesStmt]">
         <assert test="@type=('editorial', 'summary', 'thematicCom', 'incipit', 'textConst', 'translation', 'restriction')">Within the notesStmt only 'editorial', 'summary', 'textConst', 'thematicCom', 'translation' or 'restriction' are allowed for @type on note.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-text-notes-42">
      <rule context="tei:note[not(parent::tei:notesStmt)]">
         <report test="@type=('editorial', 'summary', 'incipit', 'translation')">The note types 'editorial', 'summary', 'thematicCom' or 'translation' are not allowed within the text section but only in the notesStmt.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-thematicCom-target-43">
      <rule context="tei:note[@type='thematicCom' or @target]">
         <assert test="@type='thematicCom' and @target">You need to provide thematic commentary targets (Only @type='thematicCom' and @target go together!).</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-thematicCom-must-be-empty-44">
      <rule context="tei:note[@type='thematicCom' or @target]">
         <report test="normalize-space() ne''">Thematic commentaries must not contain any text.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-structured-content-notes-45">
      <rule context="tei:note[parent::tei:notesStmt][tei:p|tei:list|tei:table]">
         <report test="text()[matches(., '\w')] or *[not(self::tei:p or self::tei:list or self::tei:table)]">There must be no mixed content when a tei:p, tei:list, or tei:table is present.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-initial-uppercase-commentaries-46">
      <rule context="tei:note[@type='commentary'][not(*[1]/self::tei:q or *[1]/self::tei:quote)]">
         <assert test="matches(replace(normalize-unicode(normalize-space(.), 'NFKD'),  '[\p{M}]', ''), '^[A-Z0-9]')">Commentary notes must start with an upper case letter.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-corresp-translation-note-ref-47">
      <rule context="tei:note[@type='translation' and @corresp]">
         <assert test="id(substring(@corresp,2))">There must be an element with the xml:id = "<value-of select="substring(@corresp,2)"/>" which is the target of this @corresp.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-note-corresp-restriction-note-ref-48">
      <rule context="tei:note[@type='restriction' and @corresp]">
         <assert test="id(substring(@corresp,2))">There must be an element with the xml:id = "<value-of select="substring(@corresp,2)"/>" which is the target of this @corresp.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-author-author-abb-49">
      <rule context="tei:author[@full]">
         <assert test="ancestor::tei:biblStruct">The full-attribute on author may only be applied within biblStruct.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-author-sameAs-reference-50">
      <rule context="tei:author[@sameAs]">
         <assert test="id(substring(@sameAs,2)) or starts-with(@sameAs, 'wega:')">There must be an element with the xml:id = "<value-of select="substring(@sameAs,2)"/>" which is the target of this @sameAs.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-author-sameAs-sameAs-reference-51">
      <rule context="tei:author[@sameAs]">
         <assert test="id(substring(@sameAs,2)) or starts-with(@sameAs, 'wega:')">There must be an element with the xml:id = "<value-of select="substring(@sameAs,2)"/>" which is the target of this @sameAs.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-title-report-type-outside-text-52">
      <rule context="tei:title">
         <report test=".[@type]/ancestor::tei:teiHeader">Do not use the <emph>type</emph> attribute here!</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-title-duplicate-title-53">
      <rule context="tei:title[following-sibling::tei:title]">
         <let name="level" value="@level"/>
         <let name="type" value="string(@type)"/>
         <let name="lang" value="string(@xml:lang)"/>
         <report test="following-sibling::tei:title[@level = $level][string(@xml:lang) = $lang][string(@type) = $type]">Following title without differing @type or xml:lang attribute</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-title-punctuation-mark-54">
      <rule context="tei:title">
         <report test="matches(normalize-space(self::tei:title), '[\.,;]$') and not(matches(normalize-space(self::tei:title), '((\p{Lu})|(\setc)|(\sal)|([\s\.]a)|(\sBl)|(\sAufl))\.$'))">Found a non-valid punctuation mark at the end of <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-title-report-quotation-marks-55">
      <rule context="tei:title">
         <report test="matches(., '&#34;‚Äú‚Äû')">please replace literal quotation marks with q-tags</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-l-abstractModel-structure-l-in-l-56">
      <rule context="tei:l">
         <report test="ancestor::tei:l[not(.//tei:note//tei:l[. = current()])]">
        Abstract model violation: Lines may not contain lines or lg elements.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-idno-types-match-external-identifiers-57">
      <rule context="tei:idno[@type='gnd']">
         <assert test="matches(., '^1[01]?\d{7}[0-9X]|[47]\d{6}-\d|[1-9]\d{0,7}-[0-9X]|3\d{7}[0-9X]$')">That doesn't look like a valid GND ID.</assert>
      </rule>
      <rule context="tei:idno[@type='viaf']">
         <assert test="matches(., '^[1-9]\d(\d{0,7}|\d{17,20})$')">That doesn't look like a valid VIAF ID.</assert>
      </rule>
      <rule context="tei:idno[@type='geonames']">
         <assert test="matches(., '^[1-9][0-9]{0,8}$')">That doesn't look like a valid Geonames ID.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-idno-match-external-identifiers-58">
      <rule context="tei:idno[parent::tei:place]">
         <report test="@type=('bd')">Bach IDs are not meant for places.</report>
         <report test="@type=('gnd')" role="info">There are less GND Identifier for places. Have you tried http://www.geonames.org/ ?</report>
      </rule>
      <rule context="tei:idno[parent::tei:person]">
         <report test="@type=('geonames')">Geonames IDs are not meant for persons.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-seg-activeOrPassivePerformance-59">
      <rule context="tei:seg">
         <report test="./@subtype = ('active', 'passive') and not(./@type = 'performance')">if @subtype contains 'active' or 'passive' @type has to be 'performance'</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-seg-AddresseeOrSenderCorrespondence-60">
      <rule context="tei:seg">
         <report test="./@subtype = ('sender', 'addressee') and not(./@type = 'correspondence')">if @subtype contains 'sender' or 'addressee' @type has to be 'correspondence'</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-orgNameKeyRequirement-61">
      <rule context="tei:orgName[not(parent::tei:org)]">
         <assert test="@key" role="info">@key should be used for identification.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-parent-org-62">
      <rule context="tei:orgName[parent::tei:org and not(ancestor::tei:listOrg)]">
         <report test="@key or not(@type)">It is required to give the type ('alt' or 'reg') of the name while @key is forbiden here.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-parent-org-reg-63">
      <rule context="tei:orgName[parent::tei:org and not(preceding::tei:orgName) and not(ancestor::tei:listOrg)]">
         <assert test="@type='reg'">There must exactly be one name with @type='reg'.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-parent-org-reg-64">
      <rule context="tei:orgName[parent::tei:org and preceding::tei:orgName and not(ancestor::tei:listOrg)]">
         <report test="@type='reg'">Only the first name can be of @type='reg'. Following names are supposed to be alternative names, @type='alt'.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-parent-not-org-65">
      <rule context="tei:orgName[not(parent::tei:org)]">
         <report test="@type">No @type attribute allowed here.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-orgName-parent-org-reg2-66">
      <rule context="tei:orgName[parent::tei:org and preceding::tei:orgName]">
         <report test="@type='reg'">Only the first name can be of @type='reg'. Following names are supposed to be alternative names, @type='alt'.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-persName-persNameKeyRequirement-67">
      <rule context="tei:persName[not(parent::tei:person)]">
         <assert test="@key" role="info">@key should be used for identification.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-persName-persNameTypes-68">
      <rule context="tei:persName[@type='alt' and @subtype='married']">
         <report test="count(parent::tei:person/tei:persName[@type='alt' and @subtype='married']) &gt; 1 and not(@n)"
                 role="error">If there are more than one name of marriage, please add @n to differ.</report>
         <report test="count(parent::tei:person/tei:persName[@type='alt' and @subtype='married']) = 1 and @n"
                 role="warning">If there is only one name of marriage, it is obsolete to use @n.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-org-listorg-org-status-69">
      <rule context="tei:org[not(parent::tei:listOrg)]">
         <assert test="@status">@status is missing.</assert>
      </rule>
      <rule context="tei:org[parent::tei:listOrg]">
         <report test="@status">@status is only for use at the root element.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-org-listorg-org-source-70">
      <rule context="tei:org[not(parent::tei:listOrg)]">
         <assert test="@source">@source is missing.</assert>
      </rule>
      <rule context="tei:org[parent::tei:listOrg]">
         <report test="@source">@source is only for use at the root element.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-subst-substContents1-71">
      <rule context="tei:subst">
         <assert test="child::tei:add and (child::tei:del or child::tei:surplus)">
            <name/> must have at least one child add and at least one child del or surplus</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-listOrg-listorg-relation-names-72">
      <rule context="tei:relation[parent::tei:listOrg]">
         <assert test="@name='isAssociatedWith'">The value must be "isAssociatedWith".</assert>
      </rule>
      <rule context="tei:org[parent::tei:listOrg]">
         <report test="@status">@status is only for use at the root element.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-relation-reforkeyorname-73">
      <rule context="tei:relation">
         <assert test="@ref or @key or @name">One of the attributes  'name', 'ref' or 'key' must be supplied</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-relation-activemutual-74">
      <rule context="tei:relation">
      <!-- Note: this constraint is pointless in RELAX NG land, where the
	   org=choice works. It is useful in DTD land, where the attList/@org
	   has no effect. It looks to me like it is useful in W3C XML Schema
	   land, too, which I find suprising, as I thought XSD could express
	   a disjuntion like that w/o difficulty. (But I may be reading the
	   XSD incorrectly.) ‚Äî Syd, 2018-05-01 -->
         <report test="@active and @mutual">Only one of the attributes @active and @mutual may be supplied</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-relation-activepassive-75">
      <rule context="tei:relation">
         <report test="@passive and not(@active)">the attribute 'passive' may be supplied only if the attribute 'active' is supplied</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.hendi.rend-underline-n-76">
      <rule context="*:hi[@n] | *:rend[@n]">
         <report test="@rend ne 'underline'">The @n-attribute is only supported in combination with @rend='underline'</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.hendi.restrict-check-restriction-id-pattern-77">
      <rule context="tei:*[@restrict]">
         <assert test="matches(@xml:id, 'rest\.[0-9]{1,3}')">The ID of a restricted element must be 'rest\.[0-9]{1,3}'.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-att.hendi.rotation-divRotation-78">
      <rule context="tei:*[@rotation]">
         <assert test="number(@rotation) gt 0 and number(@rotation) lt 361 and not(starts-with(@rotation,'0'))">The value must be between 1 and 360 (without leading zeros).</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-whitespaceOnlyContent-79">
      <rule context="tei:surname | tei:forename | tei:persName | mei:persName | tei:orgName | mei:corpName | tei:author[not(@sameAs)] | tei:occupation | tei:settlement | tei:country | tei:region | tei:rs | tei:workName | tei:characterName | tei:hi[not(.//tei:gap)] | tei:head | tei:note[not(@type=('thematicCom'))] | tei:placeName | tei:title | tei:seg | tei:item[not(@* or *)] | tei:term">
         <report test="normalize-space(.) = ''">
            <name/> has whitespace only content</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-elementStartsWithWhitespace-80">
      <rule context="tei:surname[not(./child::element())] | tei:forename | tei:persName[not(@type)][not(./child::element())] | tei:author | tei:occupation | tei:settlement[not(tei:address)][not(./child::element())] | tei:country | tei:region | tei:rs[not(./child::element())] | tei:workName | tei:characterName | tei:hi[@rend[not(.='underline' and ancestor::tei:TEI//tei:handNote[1]/@script = 'typescript')]] | tei:placeName[not(parent::tei:address or parent::tei:birth or parent::tei:death)][not(./child::element())]">
         <report test="matches(.,'^\s') and (node()[1] = text()[1]) and not(node()[2])"
                 role="error">Caution: whitespace at the beginning of &lt;<name/>&gt;</report>
         <report test="matches(.,'^\s') and (node()[1] = text()[1]) and node()[2] and not(matches(text()[1],'^\s+$'))"
                 role="error">Caution: whitespace at the beginning of &lt;<name/>&gt;</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-hiRendUnderlineStartsWithWhitespace-81">
      <rule context="tei:hi[@rend='underline' and ancestor::tei:TEI//tei:handNote[1]/@script = 'typescript']">
         <report test="matches(.,'^\s') and (node()[1] = text()[1]) and not(node()[2])"
                 role="warning">Caution: the whitespace will be rendered. Be sure that this is your intention!</report>
         <report test="matches(.,'^\s') and (node()[1] = text()[1]) and node()[2] and not(matches(text()[1],'^\s+$'))"
                 role="warning">Caution: the whitespace will be rendered. Be sure that this is your intention!</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-untrimmedAttributeValues-82">
      <rule context="*">
         <report test="some $i in @* satisfies string-length(normalize-unicode(normalize-space(replace($i, '¬†|‚ÄÇ|‚ÄÉ|‚Äâ', ' ')))) ne string-length($i)">There is some whitespace here at the beginning or end of some attribute value.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-hendiTargets-83">
      <rule context="*[starts-with(@target, 'hendi:')]">
         <assert test="matches(@target, '^hendi:A\d{2}[0-9A-F]{5}(#.+)?(\s+hendi:A\d{2}[0-9A-F]{5}(#.+)?)*$')">"hwh"-prefixed URIs must follow the pattern "hendi:A\d{2}[0-9A-F]{5}" (i.e. without any file extension)</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-emojiCheck-84">
      <rule context="*[some $i in text() satisfies normalize-space($i) ne '']">
         <report test="matches(.,                         '[‚åö-‚åõ]|[‚è©-‚è¨]|[‚è∞]|[‚è≥]|[‚óΩ-‚óæ]|[‚òî-‚òï]|[‚ôà-‚ôì]|[‚ôø]|[‚öì]|[‚ö°]|[‚ö™-‚ö´]|[‚öΩ-‚öæ]|[‚õÑ-‚õÖ]|[‚õé]|[‚õî]|[‚õ™]|[‚õ≤-‚õ≥]|[‚õµ]|[‚õ∫]|[‚õΩ]|[‚úÖ]|[‚úä-‚úã]|[‚ú®]|[‚ùå]|[‚ùé]|[‚ùì-‚ùï]|[‚ùó]|[‚ûï-‚ûó]|[‚û∞]|[‚ûø]|[‚¨õ-‚¨ú]|[‚≠ê]|[‚≠ï]|[üÄÑ]|[üÉè]|[üÜé]|[üÜë-üÜö]|[üá¶-üáø]|[üàÅ]|[üàö]|[üàØ]|[üà≤-üà∂]|[üà∏-üà∫]|[üâê-üâë]|[üåÄ-üå†]|[üå≠-üåØ]|[üå∞-üåµ]|[üå∑-üçº]|[üçæ-üçø]|[üéÄ-üéì]|[üé†-üèÑ]|[üèÖ]|[üèÜ-üèä]|[üèè-üèì]|[üè†-üè∞]|[üè¥]|[üè∏-üèø]|[üêÄ-üêæ]|[üëÄ]|[üëÇ-üì∑]|[üì∏]|[üìπ-üìº]|[üìø]|[üîÄ-üîΩ]|[üïã-üïé]|[üïê-üïß]|[üï∫]|[üñï-üññ]|[üñ§]|[üóª-üóø]|[üòÄ]|[üòÅ-üòê]|[üòë]|[üòí-üòî]|[üòï]|[üòñ]|[üòó]|[üòò]|[üòô]|[üòö]|[üòõ]|[üòú-üòû]|[üòü]|[üò†-üò•]|[üò¶-üòß]|[üò®-üò´]|[üò¨]|[üò≠]|[üòÆ-üòØ]|[üò∞-üò≥]|[üò¥]|[üòµ-üôÄ]|[üôÅ-üôÇ]|[üôÉ-üôÑ]|[üôÖ-üôè]|[üöÄ-üõÖ]|[üõå]|[üõê]|[üõë-üõí]|[üõï]|[üõ´-üõ¨]|[üõ¥-üõ∂]|[üõ∑-üõ∏]|[üõπ]|[üõ∫]|[üü†-üü´]|[ü§ç-ü§è]|[ü§ê-ü§ò]|[ü§ô-ü§û]|[ü§ü]|[ü§†-ü§ß]|[ü§®-ü§Ø]|[ü§∞]|[ü§±-ü§≤]|[ü§≥-ü§∫]|[ü§º-ü§æ]|[ü§ø]|[ü•Ä-ü•Ö]|[ü•á-ü•ã]|[ü•å]|[ü•ç-ü•è]|[ü•ê-ü•û]|[ü•ü-ü•´]|[ü•¨-ü•∞]|[ü•±]|[ü•≥-ü•∂]|[ü•∫]|[ü•ª]|[ü•º-ü•ø]|[ü¶Ä-ü¶Ñ]|[ü¶Ö-ü¶ë]|[ü¶í-ü¶ó]|[ü¶ò-ü¶¢]|[ü¶•-ü¶™]|[ü¶Æ-ü¶Ø]|[ü¶∞-ü¶π]|[ü¶∫-ü¶ø]|[üßÄ]|[üßÅ-üßÇ]|[üßÉ-üßä]|[üßç-üßè]|[üßê-üß¶]|[üßß-üßø]|[ü©∞-ü©≥]|[ü©∏-ü©∫]|[ü™Ä-ü™Ç]|[ü™ê-ü™ï]')">Text contains characters with Emoji presentation as default.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-sourceMustResolve-85">
      <rule context="*[starts-with(@source, '#')]">
         <let name="source" value="@source"/>
         <assert test="id(substring($source,2))">Unable to locate the reference provided by the @source attribute.</assert>
      </rule>
   </pattern>
   <schema queryBinding="xslt2">
      <function xmlns="http://www.w3.org/1999/XSL/Transform" name="hendi-xsl:int2hex">
         <param name="number" as="xs:int"/>
         <variable name="chars"
                   select="('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')"/>
         <variable name="div" select="$number div 16"/>
         <variable name="count" select="floor($div)"/>
         <variable name="remainder" select="($div - $count) * 16"/>
         <value-of select="concat(if($count gt 15) then hendi-xsl:int2hex(xs:integer($count))                             else if($number gt 15) then $chars[$count +1]                             else (),                             $chars[$remainder +1])"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="hendi-xsl:compute-check-digit">
         <param name="id" as="xs:string"/>
         <variable name="weights" select="(2, 4, 6, 8, 9, 5, 3)"/>
         <variable name="str2codepts" select="string-to-codepoints($id)"/>
         <variable name="str2codepts-1" select="$str2codepts[1] * $weights[1]"/>
         <variable name="str2codepts-2" select="$str2codepts[2] * $weights[2]"/>
         <variable name="str2codepts-3" select="$str2codepts[3] * $weights[3]"/>
         <variable name="str2codepts-4" select="$str2codepts[4] * $weights[4]"/>
         <variable name="str2codepts-5" select="$str2codepts[5] * $weights[5]"/>
         <variable name="str2codepts-6" select="$str2codepts[6] * $weights[6]"/>
         <variable name="str2codepts-7" select="$str2codepts[7] * $weights[7]"/>
         <variable name="sum"
                   select="sum(($str2codepts-1, $str2codepts-2, $str2codepts-3, $str2codepts-4, $str2codepts-5, $str2codepts-6, $str2codepts-7))"/>
         <value-of select="hendi-xsl:int2hex(xs:int($sum mod 16))"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="hendi-xsl:checkIdByCheckDigit">
         <param name="str" as="xs:string"/>
         <variable name="idStr" select="substring($str, 1, 7)"/>
         <variable name="idCheckDigit" select="substring($str, 8, 1)"/>
         <variable name="computedCheckDigit"
                   select="hendi-xsl:compute-check-digit($idStr)"/>
         <variable name="check" select="$computedCheckDigit = $idCheckDigit"/>
         <value-of select="$check"/>
      </function>
      <pattern id="idCheckDigit">
         <rule context="@key | @xml:id[not(parent::tei:layout) and not(parent::tei:handNote) and not(parent::tei:foreign) and not(parent::tei:div) and not(parent::tei:p) and not(parent::tei:seg)] | @sameAs | @codedval[not(parent::mei:language)] | tei:ref[@type='deletion' or @type='duplicate']/@target | @scribe">
            <assert test="hendi-xsl:checkIdByCheckDigit(.) = true()" role="fatal">Something went wrong with the ID: <value-of select="."/>. Computed check digit is <value-of select="hendi-xsl:compute-check-digit(.)"/>.</assert>
         </rule>
      </pattern>
   </schema>
   <schema queryBinding="xslt2">
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="functx:escape-for-regex"
                as="xs:string">
         <param name="arg" as="xs:string?"/>
         <sequence select="replace($arg, '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1')"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="functx:substring-before-last"
                as="xs:string">
         <param name="arg" as="xs:string?"/>
         <param name="delim" as="xs:string"/>
         <sequence select="if (matches($arg, functx:escape-for-regex($delim))) then replace($arg, concat('^(.*)', functx:escape-for-regex($delim),'.*'), '$1') else ''"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="functx:substring-after-last"
                as="xs:string">
         <param name="arg" as="xs:string?"/>
         <param name="delim" as="xs:string"/>
         <sequence select="replace ($arg,concat('^.*', functx:escape-for-regex($delim)),'')"/>
      </function>
      <pattern id="checkFilesNameAndDir">
         <rule context="root()">
            <let name="docUri" value="document-uri(.)"/>
            <let name="fileName"
                 value="functx:substring-after-last(substring-before($docUri, '.xml'), '/')"/>
            <let name="fileDir"
                 value="functx:substring-after-last(functx:substring-before-last($docUri, '/'), '/')"/>
            <assert test="./node()/@xml:id = $fileName" role="error">The id of this record does not match the files name. Please check!</assert>
            <assert test="$fileDir = concat(substring($fileName,1,5),'xxx')" role="error">The file is stored in the wrong directory. Please check!</assert>
         </rule>
      </pattern>
   </schema>
   <pattern id="schematron-constraint-hendiOrgs-addWithoutPlace-88">
      <rule context="tei:add[not(parent::tei:subst)]">
         <assert test="@place">Missing @place, because this is no substitution here.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-nameTypeRequirement-89">
      <rule context="tei:name[not(ancestor::tei:teiHeader)]">
         <assert test="@type">@type is required at <name/>.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-lbInsideAddress-90">
      <rule context="tei:lb">
         <report test="parent::tei:address" role="info">Does <name/> mark a new line inside the address? If yes, please use &lt;addrLine&gt; instead of <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-renditionWithPosition-91">
      <rule context="tei:addrLine[@rend and not(contains(@rend,' '))] | tei:dateline[@rend and not(contains(@rend,' '))]">
         <assert test="@rend = ('right','center','left')">If only one value is set, it should should address the horizontal position ('right','center','left')</assert>
      </rule>
      <rule context="tei:addrLine[@rend] | tei:dateline[@rend]">
         <assert test="tokenize(@rend, ' ')[1] = ('top','middle','bottom','inline')">the first value should address the vertical position ('top','middle','bottom')</assert>
         <assert test="tokenize(@rend, ' ')[2] = ('right','center','left')">the second value should address the horizontal position ('right','center','left')</assert>
      </rule>
   </pattern>
   <pattern id="node-typeNkey" abstract="true">
      <rule context="$node[@type='person'][@key]|$node[@type='character'][@key]|$node[@type='actingRole'][@key]|$node[@type='myth'][@key]">
         <assert test="matches(@key, '^A00[0-9A-F]{5}$')">A type value of 'person' must have only one key, starting with 'A00'</assert>
      </rule>
      <rule context="$node[@type='persons'][@key]|$node[@type='characters'][@key]|$node[@type='actingRoles'][@key]|$node[@type='myths'][@key]">
         <assert test="matches(@key, '^(A00[0-9A-F]{5}\s)*A00[0-9A-F]{5}$')">A type value of 'persons' must have at least one key, each starting with 'A00'</assert>
      </rule>
      <rule context="$node[@type='work'][@key]">
         <assert test="matches(@key, '^A02[0-9A-F]{5}$')">A type value of 'work' must have only one key, starting with 'A02'</assert>
      </rule>
      <rule context="$node[@type='works'][@key]">
         <assert test="matches(@key, '(A02[0-9A-F]{5}\s)*(A02[0-9A-F]{5})')">A type value of 'works' must have at least two key, each starting with 'A02'</assert>
      </rule>
      <rule context="$node[@type='writing'][@key]">
         <assert test="matches(@key, '^A03[0-9A-F]{5}$')">A type value of 'writing' must have only one key, starting with 'A03'</assert>
      </rule>
      <rule context="$node[@type='writings'][@key]">
         <assert test="matches(@key, '^(A03[0-9A-F]{5}\s)*A03[0-9A-F]{5}$')">A type value of 'writings' must have at least two key, each starting with 'A03'</assert>
      </rule>
      <rule context="$node[@type='postal'][@key]">
         <assert test="matches(@key, '^A04[0-9A-F]{5}$')">A type value of 'letter' must have only one key, starting with 'A04'</assert>
      </rule>
      <rule context="$node[@type='postals'][@key]">
         <assert test="matches(@key, '^(A04[0-9A-F]{5}\s)*A04[0-9A-F]{5}$')">A type value of 'letters' must have at least two key, each starting with 'A04'</assert>
      </rule>
      <rule context="$node[@type='news'][@key]">
         <assert test="matches(@key, '^(A05[0-9A-F]{5}\s)*A05[0-9A-F]{5}$')">A type value of 'news' must have at least two key, starting with 'A05'</assert>
      </rule>
      <rule context="$node[@type='org'][@key]">
         <assert test="matches(@key, '^A08[0-9A-F]{5}$')">A type value of 'org' must have only one key, starting with 'A08'</assert>
      </rule>
      <rule context="$node[@type='orgs'][@key]">
         <assert test="matches(@key, '^(A08[0-9A-F]{5}\s)*A08[0-9A-F]{5}$')">A type value of 'orgs' must have at least two key, each starting with 'A08'</assert>
      </rule>
      <rule context="$node[@type='document'][@key]">
         <assert test="matches(@key, '^A10[0-9A-F]{5}$')">A type value of 'document' must have only one key, starting with 'A10'</assert>
      </rule>
      <rule context="$node[@type='documents'][@key]">
         <assert test="matches(@key, '^(A10[0-9A-F]{5}\s)*A10[0-9A-F]{5}$')">A type value of 'documents' must have at least two key, each starting with 'A10'</assert>
      </rule>
      <rule context="$node[@type='biblio'][@key]">
         <assert test="matches(@key, '^(A11[0-9A-F]{5}\s)*A11[0-9A-F]{5}$')">A type value of 'biblio' must have at least one key, each starting with 'A11'</assert>
      </rule>
      <rule context="$node[@type='addenda'][@key]">
         <assert test="matches(@key, '^A12[0-9A-F]{5}$')">A type value of 'addenda' must have only one key, starting with 'A12'</assert>
      </rule>
      <rule context="$node[@type='place'][@key] | $node[@type='venue'][@key]">
         <assert test="matches(@key, '^A13[0-9A-F]{5}$')">A type value of 'place' must have only one key, starting with 'A13'</assert>
      </rule>
      <rule context="$node[@type='places'][@key]">
         <assert test="matches(@key, '^(A13[0-9A-F]{5}\s)*A13[0-9A-F]{5}$')">A type value of 'places' must have at least two key, each starting with 'A13'</assert>
      </rule>
      <rule context="$node[@type='mixed'][@key]">
         <assert test="count(distinct-values(for $i in tokenize(@key, '\s+') return substring($i, 1, 3))) gt 1">A type value of 'mixed' must have keys referring to different document types</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-importName-93">
      <rule context="tei:persName | tei:orgName | tei:placeName">
         <report test="(@type='import') and parent::node()/@status[.='proposed']"
                 role="info">This element should be deleted after checking this record.</report>
         <report test="(@type='import') and parent::node()/@status[.='candidate']"
                 role="warning">This element should be deleted after checking this record.</report>
         <report test="(@type='import') and parent::node()/@status[.='approved']"
                 role="error">This element has to be deleted before publishing!</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-quotation-rend-values-94">
      <rule context="*:q[@rend]/@rend | *:quote[@rend]/@rend">
         <report test="contains(.,'none')">The value 'none' is not allowed at <value-of select="node-name()"/>.</report>
      </rule>
      <rule context="*:q[@rendLeft]/@rendLeft | *:quote[@rendLeft]/@rendLeft | *:q[@rendRight]/@rendRight | *:quote[@rendRight]/@rendRight">
         <report test="contains(.,'none') and not(. = 'none')">If the value 'none' is used, no other specification are allowed.</report>
      </rule>
      <rule context="*:q[@rend]/@rend | *:quote[@rend]/@rend | *:q[@rendLeft]/@rendLeft | *:quote[@rendLeft]/@rendLeft | *:q[@rendRight]/@rendRight | *:quote[@rendRight]/@rendRight">
         <report test="(contains(.,'single') and contains(.,'double')) or (contains(., 'up') and contains(.,'down'))">Please check the values at the attriute <value-of select="node-name()"/>.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-quotation-rend-attributes-95">
      <rule context="*:q[@rend] | *:quote[@rend] | *:q[@rendLeft] | *:quote[@rendLeft] | *:q[@rendRight] | *:quote[@rendRight]">
         <report test="(@rend and @rendLeft) or (@rend and @rendLeft)">The attribute rend is not allowed if rendLeft or rendRight is used.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-rendIfBreakNo-97">
      <rule context="tei:lb | tei:pb">
         <assert test="not(@*) or @n or @break or (@break and @rend)">@rend is only allowed if @break is used.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-reportLBfollowsPB-98">
      <rule context="tei:pb">
         <report test=".[following::lb]">A lb-element right after a pb-element is senseless.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-seriesTitleRequirements-99">
      <rule context="tei:fileDesc/tei:titleStmt/tei:title[@level='s']">
         <let name="seriesTitleA04" value="'Henze-Digital, Briefedition'"/>
         <let name="seriesTitleA05" value="'Aktuelle Nachrichten von Henze-Digital'"/>
         <let name="seriesTitleA02"
              value="'Henze-Digital, literarische Werke, Digitale Edition'"/>
         <report test="ancestor::tei:TEI[starts-with(@xml:id,'A04')] and not(. = $seriesTitleA04)">The correct series title for postals is "<value-of select="$seriesTitleA04"/>".</report>
         <report test="ancestor::tei:TEI[starts-with(@xml:id,'A05')] and not(. = $seriesTitleA05)">The scorrect eries title for News is "<value-of select="$seriesTitleA05"/>".</report>
         <report test="ancestor::tei:TEI[starts-with(@xml:id,'A02')] and not(. = $seriesTitleA02)">The series title must be "<value-of select="$seriesTitleA02"/>".</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-correspDescControl-100">
      <rule context="tei:profileDesc">
         <report test="ancestor::tei:TEI[starts-with(@xml:id, 'A04')] and not(tei:correspDesc)"
                 role="fatal">&lt;profileDesc&gt; is required for postals.</report>
         <report test="ancestor::tei:TEI[starts-with(@xml:id, 'A10')] and tei:correspDesc"
                 role="fatal">&lt;profileDesc&gt; is only allowed for postals.</report>
      </rule>
      <rule context="tei:correspDesc">
         <report test="ancestor::tei:TEI[starts-with(@xml:id, 'A14')]" role="fatal">&lt;correspDesc&gt; is only allowed for postals.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-textTypeControl-101">
      <rule context="tei:text/@type">
         <let name="textTypePostals"
              value="('card.business','card.letter','card.postal','contract','document','envelope','fax','formCommitment','letter','note.telephone','note.conversation','statement','statement.fee','telegram','unknown')"/>
         <let name="textTypeDocuments"
              value="('personal_document','financial_document','varia_document','notification_document','konzertzettel_document','work-related_document','legal_document','theater_document')"/>
         <report test="ancestor::tei:TEI[starts-with(@xml:id, 'A04')] and not(. = $textTypePostals)"
                 role="error">For postals the value of @type must be one of <value-of select="$textTypePostals"/>.</report>
         <report test="ancestor::tei:TEI[starts-with(@xml:id, 'A10')] and not(. = $textTypeDocuments)"
                 role="error">For documents the value of @type must be one of <value-of select="$textTypeDocuments"/>.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hendiOrgs-styleguide-document-node-content-102">
      <rule context="document-node()">
         <report test="count(processing-instruction()) ne 2">Henze-Digital styleguide error: there should exactly be two processing instructions before the root element</report>
         <report test="comment()">Henze-Digital styleguide error: there should be no comments outside the root element</report>
      </rule>
   </pattern>
</schema>
