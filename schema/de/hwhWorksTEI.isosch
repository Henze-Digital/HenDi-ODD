<?xml version="1.0" encoding="utf-8"?>
<schema xmlns="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2">
   <title>ISO Schematron rules</title>
   <!-- This file generated 2022-01-18T07:22:19Z by 'extract-isosch.xsl'. -->
   <!-- ********************* -->
   <!-- namespaces, declared: -->
   <!-- ********************* -->
   <ns prefix="tei" uri="http://www.tei-c.org/ns/1.0"/>
   <ns prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/>
   <ns prefix="rng" uri="http://relaxng.org/ns/structure/1.0"/>
   <ns uri="https://henze-digital.de/ns/xslt-functions" prefix="hwh-xsl"/>
   <!-- ********************* -->
   <!-- namespaces, implicit: -->
   <!-- ********************* -->
   <ns prefix="dcr" uri="http://www.isocat.org/ns/dcr"/>
   <!-- ************ -->
   <!-- constraints: -->
   <!-- ************ -->
   <pattern id="schematron-constraint-hwhWorksTEI-att.written-hand-hand-reference-1">
      <rule context="tei:*[@hand]">
         <assert test="id(substring(@hand,2)) or starts-with(@hand, 'hwh:')">There must be an element with the xml:id = "<value-of select="substring(@hand,2)"/>" which is the target of this @hand.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.breaking-break-hyphenation-whitespace-2">
      <rule context="tei:*[@break]">
         <report test="matches((following-sibling::text() | following-sibling::element())[1], '^\s') or matches((preceding-sibling::text() | preceding-sibling::element())[last()], '\s$')">There must not be any whitespace before or after the <name/> element when the @break attribute is applied.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.datable.w3c-att-datable-w3c-when-3">
      <rule context="tei:*[@when]">
         <report test="@notBefore|@notAfter|@from|@to" role="nonfatal">The @when attribute cannot be used with any other att.datable.w3c attributes.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.datable.w3c-att-datable-w3c-from-4">
      <rule context="tei:*[@from]">
         <report test="@notBefore" role="nonfatal">The @from and @notBefore attributes cannot be used together.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.datable.w3c-att-datable-w3c-to-5">
      <rule context="tei:*[@to]">
         <report test="@notAfter" role="nonfatal">The @to and @notAfter attributes cannot be used together.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.datable-calendar-calendar-6">
      <rule context="tei:*[@calendar]">
         <assert test="string-length(.) gt 0"> @calendar indicates one or more systems or calendars to
              which the date represented by the content of this element belongs, but this
              <name/> element has no textual content.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.typed-subtypeTyped-7">
      <rule context="tei:*[@subtype]">
         <assert test="@type">The <name/> element should not be categorized in detail with @subtype unless also categorized in general with @type</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.spanning-spanTo-spanTo-2-8">
      <rule context="tei:*[@spanTo]">
         <assert test="id(substring(@spanTo,2)) and following::*[@xml:id=substring(current()/@spanTo,2)]">
The element indicated by @spanTo (<value-of select="@spanTo"/>) must follow the current element <name/>
         </assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-p-abstractModel-structure-p-9">
      <rule context="tei:p">
         <report test="not(ancestor::tei:floatingText) and (ancestor::tei:p or ancestor::tei:ab)          and not(parent::tei:exemplum                |parent::tei:item                |parent::tei:note                |parent::tei:q                |parent::tei:quote                |parent::tei:remarks                |parent::tei:said                |parent::tei:sp                |parent::tei:stage                |parent::tei:cell                |parent::tei:figure                )">
        Abstract model violation: Paragraphs may not occur inside other paragraphs or ab elements.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-p-abstractModel-structure-l-10">
      <rule context="tei:p">
         <report test="(ancestor::tei:l or ancestor::tei:lg) and not(parent::tei:figure or parent::tei:note or ancestor::tei:floatingText)">
        Abstract model violation: Lines may not contain higher-level structural elements such as div, p, or ab, unless p is a child of figure or note, or is a descendant of floatingText.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-desc-deprecationInfo-only-in-deprecated-11">
      <rule context="tei:desc[ @type eq 'deprecationInfo']">
         <assert test="../@validUntil">Information about a
        deprecation should only be present in a specification element
        that is being deprecated: that is, only an element that has a
        @validUntil attribute should have a child &lt;desc
        type="deprecationInfo"&gt;.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-del-rend-rendAtDel-12">
      <rule context="tei:del[not(@rend)]">
         <assert test="parent::tei:subst" role="info">This is not a substitution, so if you don't specify the rendition (@rend) this will be interpreted as a total deletion.</assert>
      </rule>
   </pattern>
   <pattern is-a="node-typeNkey">
      <param name="node" value="tei:name"/>
   </pattern>
   <pattern is-a="node-typeNkey">
      <param name="node" value="tei:rs"/>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-ptr-ptrAtts-15">
      <rule context="tei:ptr">
         <report test="@target and @cRef">Only one of the
attributes @target and @cRef may be supplied on <name/>.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-ref-refAtts-16">
      <rule context="tei:ref">
         <report test="@target and @cRef">Only one of the
	attributes @target' and @cRef' may be supplied on <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-list-gloss-list-must-have-labels-17">
      <rule context="tei:list[@type='gloss']">
         <assert test="tei:label">The content of a "gloss" list should include a sequence of one or more pairs of a label element followed by an item element</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-note-note-in-text-18">
      <rule context="tei:note[not(parent::tei:org or parent::tei:person or parent::tei:notesStmt or parent::tei:biblStruct or parent::tei:imprint or @type=('addInfo','comment'))]">
         <assert test="@resp">It is required to give a responsibillity (@resp) on note.</assert>
      </rule>
      <rule context="tei:note[not(parent::tei:org or parent::tei:person or parent::tei:notesStmt or parent::tei:biblStruct or parent::tei:imprint)]">
         <report test="@type and @resp and @xml:id">It is recommended to provide @type and @resp and @xml:id on note.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-note-text-notes-19">
      <rule context="tei:note[not(parent::tei:notesStmt)]">
         <report test="@type=('editorial', 'summary', 'incipit')">The note types 'editorial', 'summary', or 'thematicCom' are not allowed within the text section but only in the notesStmt.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-title-report-type-outside-text-20">
      <rule context="tei:title">
         <report test=".[@type]/ancestor::tei:teiHeader">Do not use the <emph>type</emph> attribute here!</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-relatedItem-targetorcontent1-21">
      <rule context="tei:relatedItem">
         <report test="@target and count( child::* ) &gt; 0">
If the @target attribute on <name/> is used, the
relatedItem element must be empty</report>
         <assert test="@target or child::*">A relatedItem element should have either a 'target' attribute
        or a child element to indicate the related bibliographic item</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-l-abstractModel-structure-l-22">
      <rule context="tei:l">
         <report test="ancestor::tei:l[not(.//tei:note//tei:l[. = current()])]">
        Abstract model violation: Lines may not contain lines or lg elements.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-lg-atleast1oflggapl-23">
      <rule context="tei:lg">
         <assert test="count(descendant::tei:lg|descendant::tei:l|descendant::tei:gap) &gt; 0">An lg element
        must contain at least one child l, lg, or gap element.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-lg-abstractModel-structure-l-24">
      <rule context="tei:lg">
         <report test="ancestor::tei:l[not(.//tei:note//tei:lg[. = current()])]">
        Abstract model violation: Lines may not contain line groups.
      </report>
      </rule>
   </pattern>
   <pattern id="isoschematron-constraint-hwhWorksTEI-teiHeader-seriesTitle-25">
      <rule context="tei:fileDesc/tei:titleStmt/tei:title[@level='s']">
         <assert test=".='Henze-Digital, literarische Werke, Digitale Edition'">The series title must be 
                        "Henze-Digital, literarische Werke, Digitale Edition".</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-language-no-language-for-revealed-correspondence-26">
      <rule context="tei:language">
         <report test="preceding-sibling::tei:correspDesc[@n='revealed'] and following::tei:body[normalize-space(.) eq '']">Revealed correspondence must not have language information.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-body-non-empty-body-needs-langUsage-29">
      <rule context="tei:body[normalize-space(.) ne '']">
         <assert test="preceding::tei:langUsage">The langUsage element must be provided when text is present.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-div-abstractModel-structure-l-30">
      <rule context="tei:div">
         <report test="(ancestor::tei:l or ancestor::tei:lg) and not(ancestor::tei:floatingText)">
        Abstract model violation: Lines may not contain higher-level structural elements such as div, unless div is a descendant of floatingText.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-div-abstractModel-structure-p-31">
      <rule context="tei:div">
         <report test="(ancestor::tei:p or ancestor::tei:ab) and not(ancestor::tei:floatingText)">
        Abstract model violation: p and ab may not contain higher-level structural elements such as div, unless div is a descendant of floatingText.
      </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-orgName-orgNameKeyRequirement-32">
      <rule context="tei:orgName[not(parent::tei:org)]">
         <assert test="@key" role="warning">A <name/> should be used for identification.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-orgName-parent-org-33">
      <rule context="tei:orgName[parent::tei:org]">
         <report test="@key or not(@type)">It is required to give the type ('alt' or 'reg') of the name while @key is forbiden here.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-orgName-parent-org-reg-34">
      <rule context="tei:orgName[parent::tei:org and not(preceding::tei:orgName)]">
         <assert test="@type='reg'">There must exactly be one name with @type='reg'.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-orgName-parent-org-reg-35">
      <rule context="tei:orgName[parent::tei:org and preceding::tei:orgName]">
         <report test="@type='reg'">Only the first name can be of @type='reg'. Following names are supposed to be alternative names, @type='alt'.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-orgName-parent-not-org-36">
      <rule context="tei:orgName[not(parent::tei:org)]">
         <report test="@type">No @type attribute allowed here.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-persName-persNameKeyRequirement-37">
      <rule context="tei:persName[not(parent::tei:person)]">
         <assert test="@key" role="warning">A <name/> should be used for identification.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-addSpan-spanTo-38">
      <rule context="tei:addSpan">
         <assert test="@spanTo">The @spanTo attribute of <name/> is required.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-subst-substContents1-40">
      <rule context="tei:subst">
         <assert test="child::tei:add and (child::tei:del or child::tei:surplus)">
            <name/> must have at least one child add and at least one child del or surplus</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-msIdentifier-msId_minimal-41">
      <rule context="tei:msIdentifier">
         <report test="not(parent::tei:msPart) and (local-name(*[1])='idno' or local-name(*[1])='altIdentifier' or normalize-space(.)='')">An msIdentifier must contain either a repository or location.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-physDesc-empty-physDesc-42">
      <rule context="tei:physDesc">
         <assert test="*">
            <name/> must contain at least one p or objectDesc or accMat element</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-whitespaceOnlyContent-43">
      <rule context="tei:surname | tei:forename | tei:persName | tei:author[not(@sameAs)] | tei:occupation | tei:settlement | tei:country | tei:region | tei:rs | tei:workName | tei:characterName | tei:hi[not(.//tei:gap)] | tei:head | tei:note[not(@type=('thematicCom'))] | tei:placeName | tei:title | tei:seg | tei:item[not(@* or *)] | tei:term">
         <report test="normalize-space(.) = ''">
            <name/> has whitespace only content</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-elementStartsWithWhitespace-44">
      <rule context="tei:surname | tei:forename | tei:persName[not(@type)][not(./child::element())] | tei:author | tei:occupation | tei:settlement[not(tei:address)][not(./child::element())] | tei:country | tei:region | tei:rs[not(./child::element())] | tei:workName | tei:characterName | tei:hi | tei:placeName[not(parent::tei:address or parent::tei:birth or parent::tei:death)][not(./child::element())]">
         <report test="matches(.,'^\s') and (node()[1] = text()[1])">whitespace at the beginning of element <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-untrimmedAttributeValues-45">
      <rule context="*">
         <report test="some $i in @* satisfies string-length(normalize-unicode(normalize-space(replace($i, 'Â |â€‚|â€ƒ|â€‰', ' ')))) ne string-length($i)">There is some whitespace here at the beginning or end of some attribute value.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-hwhTargets-46">
      <rule context="*[starts-with(@target, 'hwh:')]">
         <assert test="matches(@target, '^hwh:A\d{2}[0-9A-F]{5}(#.+)?(\s+hwh:A\d{2}[0-9A-F]{5}(#.+)?)*$')">"hwh"-prefixed URIs must follow the pattern "hwh:A\d{2}[0-9A-F]{5}" (i.e. without any file extension)</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-emojiCheck-47">
      <rule context="*[some $i in text() satisfies normalize-space($i) ne '']">
         <report test="matches(.,                         '[âŒš-âŒ›]|[â©-â¬]|[â°]|[â³]|[â—½-â—¾]|[â˜”-â˜•]|[â™ˆ-â™“]|[â™¿]|[âš“]|[âš¡]|[âšª-âš«]|[âš½-âš¾]|[â›„-â›…]|[â›Ž]|[â›”]|[â›ª]|[â›²-â›³]|[â›µ]|[â›º]|[â›½]|[âœ…]|[âœŠ-âœ‹]|[âœ¨]|[âŒ]|[âŽ]|[â“-â•]|[â—]|[âž•-âž—]|[âž°]|[âž¿]|[â¬›-â¬œ]|[â­]|[â­•]|[ðŸ€„]|[ðŸƒ]|[ðŸ†Ž]|[ðŸ†‘-ðŸ†š]|[ðŸ‡¦-ðŸ‡¿]|[ðŸˆ]|[ðŸˆš]|[ðŸˆ¯]|[ðŸˆ²-ðŸˆ¶]|[ðŸˆ¸-ðŸˆº]|[ðŸ‰-ðŸ‰‘]|[ðŸŒ€-ðŸŒ ]|[ðŸŒ­-ðŸŒ¯]|[ðŸŒ°-ðŸŒµ]|[ðŸŒ·-ðŸ¼]|[ðŸ¾-ðŸ¿]|[ðŸŽ€-ðŸŽ“]|[ðŸŽ -ðŸ„]|[ðŸ…]|[ðŸ†-ðŸŠ]|[ðŸ-ðŸ“]|[ðŸ -ðŸ°]|[ðŸ´]|[ðŸ¸-ðŸ¿]|[ðŸ€-ðŸ¾]|[ðŸ‘€]|[ðŸ‘‚-ðŸ“·]|[ðŸ“¸]|[ðŸ“¹-ðŸ“¼]|[ðŸ“¿]|[ðŸ”€-ðŸ”½]|[ðŸ•‹-ðŸ•Ž]|[ðŸ•-ðŸ•§]|[ðŸ•º]|[ðŸ–•-ðŸ––]|[ðŸ–¤]|[ðŸ—»-ðŸ—¿]|[ðŸ˜€]|[ðŸ˜-ðŸ˜]|[ðŸ˜‘]|[ðŸ˜’-ðŸ˜”]|[ðŸ˜•]|[ðŸ˜–]|[ðŸ˜—]|[ðŸ˜˜]|[ðŸ˜™]|[ðŸ˜š]|[ðŸ˜›]|[ðŸ˜œ-ðŸ˜ž]|[ðŸ˜Ÿ]|[ðŸ˜ -ðŸ˜¥]|[ðŸ˜¦-ðŸ˜§]|[ðŸ˜¨-ðŸ˜«]|[ðŸ˜¬]|[ðŸ˜­]|[ðŸ˜®-ðŸ˜¯]|[ðŸ˜°-ðŸ˜³]|[ðŸ˜´]|[ðŸ˜µ-ðŸ™€]|[ðŸ™-ðŸ™‚]|[ðŸ™ƒ-ðŸ™„]|[ðŸ™…-ðŸ™]|[ðŸš€-ðŸ›…]|[ðŸ›Œ]|[ðŸ›]|[ðŸ›‘-ðŸ›’]|[ðŸ›•]|[ðŸ›«-ðŸ›¬]|[ðŸ›´-ðŸ›¶]|[ðŸ›·-ðŸ›¸]|[ðŸ›¹]|[ðŸ›º]|[ðŸŸ -ðŸŸ«]|[ðŸ¤-ðŸ¤]|[ðŸ¤-ðŸ¤˜]|[ðŸ¤™-ðŸ¤ž]|[ðŸ¤Ÿ]|[ðŸ¤ -ðŸ¤§]|[ðŸ¤¨-ðŸ¤¯]|[ðŸ¤°]|[ðŸ¤±-ðŸ¤²]|[ðŸ¤³-ðŸ¤º]|[ðŸ¤¼-ðŸ¤¾]|[ðŸ¤¿]|[ðŸ¥€-ðŸ¥…]|[ðŸ¥‡-ðŸ¥‹]|[ðŸ¥Œ]|[ðŸ¥-ðŸ¥]|[ðŸ¥-ðŸ¥ž]|[ðŸ¥Ÿ-ðŸ¥«]|[ðŸ¥¬-ðŸ¥°]|[ðŸ¥±]|[ðŸ¥³-ðŸ¥¶]|[ðŸ¥º]|[ðŸ¥»]|[ðŸ¥¼-ðŸ¥¿]|[ðŸ¦€-ðŸ¦„]|[ðŸ¦…-ðŸ¦‘]|[ðŸ¦’-ðŸ¦—]|[ðŸ¦˜-ðŸ¦¢]|[ðŸ¦¥-ðŸ¦ª]|[ðŸ¦®-ðŸ¦¯]|[ðŸ¦°-ðŸ¦¹]|[ðŸ¦º-ðŸ¦¿]|[ðŸ§€]|[ðŸ§-ðŸ§‚]|[ðŸ§ƒ-ðŸ§Š]|[ðŸ§-ðŸ§]|[ðŸ§-ðŸ§¦]|[ðŸ§§-ðŸ§¿]|[ðŸ©°-ðŸ©³]|[ðŸ©¸-ðŸ©º]|[ðŸª€-ðŸª‚]|[ðŸª-ðŸª•]')">Text contains characters with Emoji presentation as default.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-sourceMustResolve-48">
      <rule context="*[starts-with(@source, '#')]">
         <let name="source" value="@source"/>
         <assert test="id(substring($source,2))">Unable to locate the reference provided by the @source attribute.</assert>
      </rule>
   </pattern>
   <schema queryBinding="xslt2">
      <function xmlns="http://www.w3.org/1999/XSL/Transform" name="hwh-xsl:int2hex">
         <param name="number" as="xs:int"/>
         <variable name="chars"
                   select="('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')"/>
         <variable name="div" select="$number div 16"/>
         <variable name="count" select="floor($div)"/>
         <variable name="remainder" select="($div - $count) * 16"/>
         <value-of select="concat(if($count gt 15) then hwh-xsl:int2hex(xs:integer($count))                             else if($number gt 15) then $chars[$count +1]                             else (),                             $chars[$remainder +1])"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="hwh-xsl:compute-check-digit">
         <param name="id" as="xs:string"/>
         <variable name="weights" select="(2, 4, 6, 8, 9, 5, 3)"/>
         <variable name="str2codepts" select="string-to-codepoints($id)"/>
         <variable name="str2codepts-1" select="$str2codepts[1] * $weights[1]"/>
         <variable name="str2codepts-2" select="$str2codepts[2] * $weights[2]"/>
         <variable name="str2codepts-3" select="$str2codepts[3] * $weights[3]"/>
         <variable name="str2codepts-4" select="$str2codepts[4] * $weights[4]"/>
         <variable name="str2codepts-5" select="$str2codepts[5] * $weights[5]"/>
         <variable name="str2codepts-6" select="$str2codepts[6] * $weights[6]"/>
         <variable name="str2codepts-7" select="$str2codepts[7] * $weights[7]"/>
         <variable name="sum"
                   select="sum(($str2codepts-1, $str2codepts-2, $str2codepts-3, $str2codepts-4, $str2codepts-5, $str2codepts-6, $str2codepts-7))"/>
         <value-of select="hwh-xsl:int2hex(xs:int($sum mod 16))"/>
      </function>
      <function xmlns="http://www.w3.org/1999/XSL/Transform"
                name="hwh-xsl:checkIdByCheckDigit">
         <param name="str" as="xs:string"/>
         <variable name="idStr" select="substring($str, 1, 7)"/>
         <variable name="idCheckDigit" select="substring($str, 8, 1)"/>
         <variable name="computedCheckDigit" select="hwh-xsl:compute-check-digit($idStr)"/>
         <variable name="check" select="$computedCheckDigit = $idCheckDigit"/>
         <value-of select="$check"/>
      </function>
      <pattern id="idCheckDigit">
         <rule context="@key | @xml:id[not(parent::tei:layout)] | @sameAs | @codedval | tei:ref[@type='deletion' or @type='duplicate']/@target">
            <assert test="hwh-xsl:checkIdByCheckDigit(.) = true()" role="fatal">Something went wrong with the ID: <value-of select="."/>. Computed check digit is <value-of select="hwh-xsl:compute-check-digit(.)"/>.</assert>
         </rule>
      </pattern>
   </schema>
   <pattern id="schematron-constraint-hwhWorksTEI-addWithoutPlace-50">
      <rule context="tei:add[not(parent::tei:subst)]">
         <assert test="@place">Missing @place, because this is no substitution here.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-nameTypeRequirement-51">
      <rule context="tei:name[not(ancestor::tei:teiHeader)]">
         <assert test="@type">@type is required at <name/>.</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-lbInsideAddress-52">
      <rule context="tei:lb">
         <report test="parent::tei:address" role="info">Does <name/> mark a new line inside the address? If yes, please use &lt;addrLine&gt; instead of <name/>
         </report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-renditionWithPosition-53">
      <rule context="tei:addrLine[@rend and not(contains(@rend,' '))] | tei:dateline[@rend and not(contains(@rend,' '))]">
         <assert test="@rend = ('right','center','left')">If only one value is set, it should should address the horizontal position ('right','center','left')</assert>
      </rule>
      <rule context="tei:addrLine[@rend] | tei:dateline[@rend]">
         <assert test="tokenize(@rend, ' ')[1] = ('top','middle','bottom','inline')">the first value should address the vertical position ('top','middle','bottom')</assert>
         <assert test="tokenize(@rend, ' ')[2] = ('right','center','left')">the second value should address the horizontal position ('right','center','left')</assert>
      </rule>
   </pattern>
   <pattern id="node-typeNkey" abstract="true">
      <rule context="$node[@type='person'][@key]|$node[@type='character'][@key]|$node[@type='actingRole'][@key]|$node[@type='myth'][@key]">
         <assert test="matches(@key, '^A00[0-9A-F]{5}$')">A type value of 'person' must have only one key, starting with 'A00'</assert>
      </rule>
      <rule context="$node[@type='persons'][@key]|$node[@type='characters'][@key]|$node[@type='actingRoles'][@key]|$node[@type='myths'][@key]">
         <assert test="matches(@key, '^(A00[0-9A-F]{5}\s)*A00[0-9A-F]{5}$')">A type value of 'persons' must have at least one key, each starting with 'A00'</assert>
      </rule>
      <rule context="$node[@type='work'][@key]">
         <assert test="matches(@key, '^A02[0-9A-F]{5}$')">A type value of 'work' must have only one key, starting with 'A02'</assert>
      </rule>
      <rule context="$node[@type='works'][@key]">
         <assert test="matches(@key, '^(A02[0-9A-F]{5}\s)*A02\d{5}$')">A type value of 'works' must have at least one key, each starting with 'A02'</assert>
      </rule>
      <rule context="$node[@type='writing'][@key]">
         <assert test="matches(@key, '^A03[0-9A-F]{5}$')">A type value of 'writing' must have only one key, starting with 'A03'</assert>
      </rule>
      <rule context="$node[@type='writings'][@key]">
         <assert test="matches(@key, '^(A03[0-9A-F]{5}\s)*A03[0-9A-F]{5}$')">A type value of 'writings' must have at least one key, each starting with 'A03'</assert>
      </rule>
      <rule context="$node[@type='postal'][@key]">
         <assert test="matches(@key, '^A04[0-9A-F]{5}$')">A type value of 'letter' must have only one key, starting with 'A04'</assert>
      </rule>
      <rule context="$node[@type='postals'][@key]">
         <assert test="matches(@key, '^(A04[0-9A-F]{5}\s)*A04[0-9A-F]{5}$')">A type value of 'letters' must have at least one key, each starting with 'A04'</assert>
      </rule>
      <rule context="$node[@type='news'][@key]">
         <assert test="matches(@key, '^(A05[0-9A-F]{5}\s)*A05[0-9A-F]{5}$')">A type value of 'news' must have at least one key, starting with 'A05'</assert>
      </rule>
      <rule context="$node[@type='diaryDay'][@key]">
         <assert test="matches(@key, '^A06[0-9A-F]{5}$')">A type value of 'diaryDay' must have only one key, starting with 'A06'</assert>
      </rule>
      <rule context="$node[@type='diaryDays'][@key]">
         <assert test="matches(@key, '^(A06[0-9A-F]{5}\s)*A06[0-9A-F]{5}$')">A type value of 'diaryDays' must have at least one key, each starting with 'A06'</assert>
      </rule>
      <rule context="$node[@type='org'][@key]">
         <assert test="matches(@key, '^A08[0-9A-F]{5}$')">A type value of 'org' must have only one key, starting with 'A08'</assert>
      </rule>
      <rule context="$node[@type='orgs'][@key]">
         <assert test="matches(@key, '^(A08\d{5}\s)*A08\d{5}$')">A type value of 'orgs' must have at least one key, each starting with 'A08'</assert>
      </rule>
      <rule context="$node[@type='document'][@key]">
         <assert test="matches(@key, '^A10\d{5}$')">A type value of 'document' must have only one key, starting with 'A10'</assert>
      </rule>
      <rule context="$node[@type='documents'][@key]">
         <assert test="matches(@key, '^(A10[0-9A-F]{5}\s)*A10[0-9A-F]{5}$')">A type value of 'documents' must have at least one key, each starting with 'A10'</assert>
      </rule>
      <rule context="$node[@type='biblio'][@key]">
         <assert test="matches(@key, '^(A11[0-9A-F]{5}\s)*A11[0-9A-F]{5}$')">A type value of 'biblio' must have at least one key, each starting with 'A11'</assert>
      </rule>
      <rule context="$node[@type='addenda'][@key]">
         <assert test="matches(@key, '^A12[0-9A-F]{5}$')">A type value of 'addenda' must have only one key, starting with 'A12'</assert>
      </rule>
      <rule context="$node[@type='place'][@key] | $node[@type='venue'][@key]">
         <assert test="matches(@key, '^A13[0-9A-F]{5}$')">A type value of 'place' must have only one key, starting with 'A13'</assert>
      </rule>
      <rule context="$node[@type='places'][@key]">
         <assert test="matches(@key, '^(A13[0-9A-F]{5}\s)*A13[0-9A-F]{5}$')">A type value of 'places' must have at least one key, each starting with 'A13'</assert>
      </rule>
      <rule context="$node[@type='mixed'][@key]">
         <assert test="count(distinct-values(for $i in tokenize(@key, '\s+') return substring($i, 1, 3))) gt 1">A type value of 'mixed' must have keys referring to different document types</assert>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-importName-55">
      <rule context="tei:persName | tei:orgName | tei:placeName">
         <report test="@type='import'" role="info">This element should be deleted after checking this record.</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-styleguide-document-node-content-56">
      <rule context="document-node()">
         <report test="count(processing-instruction()) ne 2">Henze-Digital styleguide error: there should exactly be two processing instructions before the root element</report>
         <report test="comment()">Henze-Digital styleguide error: there should be no comments outside the root element</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-styleguide-document-node-content-57">
      <rule context="document-node()">
         <report test="count(processing-instruction()) ne 2">Henze-Digital styleguide error: there should exactly be two processing instructions before the root element</report>
         <report test="comment()">Henze-Digital styleguide error: there should be no comments outside the root element</report>
      </rule>
   </pattern>
   <pattern id="schematron-constraint-hwhWorksTEI-att.hwh.rend-underline-n-58">
      <rule context="*:hi[@n] | *:rend[@n]">
         <report test="@rend ne 'underline'">The @n-attribute is only supported in combination with @rend='underline'</report>
      </rule>
   </pattern>
</schema>
